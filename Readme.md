# ServerHMAC

Простой HTTP-сервер для генерации и проверки HMAC-подписей, реализованный без использования фреймворков и систем сборки.  
Сервер принимает JSON-запросы на подпись и верификацию сообщений, используя заданный алгоритм HMAC и секретный ключ.

## Функциональность

- Подпись сообщения по эндпоинту `POST /sign`
- Проверка подписи по эндпоинту `POST /verify`
- Поддержка JSON в теле запроса
- Валидация метода, Content-Type, размера тела и обязательных полей
- Защита от переполнения (ограничение размера тела)
- Ротация секрета (через shell скрипт)
- Простой пайп для сборки, запуска и контейнеризации через консольные вызовы

## API

### `POST /sign`
**Тело запроса:**
```json 
{ 
  "msg": "test message"
}
```
**Ответ:**
```json
{
"signature": "P0OexNSMup6vIouWoI-3tnfhB-FkGrVw9R_EzVmC_e0\u003d" 
}
```
**Пример вызова:**
``` bash
curl -sS -X POST http://localhost:8080/sign \
  -H 'Content-Type: application/json' \
  -d '{"msg":"hello"}'
```

### `POST /verify`

**Тело запроса:**
```json
{
  "msg": "test message", "signature": "P0OexNSMup6vIouWoI-3tnfhB-FkGrVw9R_EzVmC_e0\u003d"
}
```
**Ответ:**
```json
 {
  "isValid": "true"
}
```
**Пример вызова:**
``` bash
curl -sS -X POST http://localhost:8080/verify \
  -H 'Content-Type: application/json' \
  -d '{"msg":"test message","signature":"P0OexNSMup6vIouWoI-3tnfhB-FkGrVw9R_EzVmC_e0\u003d"}'
```

## Конфигурация

Конфигурация загружается из файла `config.json` в classpath. Пример:
```json
{
  "listenPort": 8080,
  "maxMsgSizeBytes": 1024,
  "hmacAlg": "SHA256",
  "secret": "P0OexNSMup6vIouWoI-3tnfhB-FkGrVw9R_EzVmC_e0\u003d"
}
```


## Требования к окружению

- Java 21+
- Docker (опционально)
- openssl (опционально)

## Запуск
Для простоты запуска реализован ряд скриптов в директории [scripts](scripts) (описание скриптов ниже).
Все скрипты необходимо запускать из корневой директории проекта.
Необходимо наличие среды для запуска `sh` скриптов (например Git Bash для Windows).

При наличии Docker достаточно вызвать `./scripts/build.sh`. 
При его отсутствии необходимо вызвать `./scripts/compile.sh` для компиляции и `./scripts/run-java.sh` для локального запуска.
Запущенное приложение по умолчанию будет доступно по адресу `localhost:8080`

## Описание скриптов

### build.sh ###
Составной скрипт, запускающий:
- Сборку приложения (`compile.sh`)
- Тесты (`run-tests.sh`)
- Подготовку jar файла и зависимостей (`assemble.sh`)
- Создание и запуск docker контейнера с приложением (`dockerize.sh`)

**Требования к окружению:**
- JDK 21
- Docker

**Пример вызова:**
```sh
./scripts/build.sh
```
---
### compile.sh ###
Скрипт, запускающий сборку приложения (основной и тестовой части)

**Требования к окружению:**
- JDK 21

**Пример вызова:**
```sh
./scripts/compile.sh
```
---
### run-tests.sh ###
Скрипт, запускающий тесты приложения через вызов [junit jar файла](junit-console)

**Требования к окружению:**
- JDK 21
- Наличие скомпилированных файлов после вызова `compile.sh`

**Пример вызова:**
```sh
./scripts/run-tests.sh
```
---
### assemble.sh ###
Скрипт, подготавливающий jar файл и необходимые зависимости

**Требования к окружению:**
- JDK 21
- Наличие скомпилированных файлов после вызова `compile.sh`

**Пример вызова:**
```sh
./scripts/assemble.sh
```
---
### dockerize.sh ###
Скрипт, собирающий образ и запускающий контейнер с приложением.

**Требования к окружению:**
- Наличие подготовленных файлов в директории app после вызова `assemble.sh`
- Docker

**Пример вызова:**
```sh
./scripts/dockerize.sh
```
---
### run-java.sh ###
Скрипт для локального запуска приложения из скомпилированных файлов.

**Требования к окружению:**
- JDK 21
- Наличие подготовленных файлов в директории app после вызова `compile.sh`

**Пример вызова:**
```sh
./scripts/run-java.sh
```
---
### rotate-secret.sh ###
Утилита для замены секрета в resources/config.json на случайно сгенерированную строку в формате Base64.

**Требования к окружению:**
- openssl

**Пример вызова:**
```sh
./scripts/rotate-secret.sh
```

## Дополнительная информация

Данная реализация - не шифрование и не юридически значимая асимметричная ЭП (нет сертификатов, меток времени, цепочек доверия и неотказуемости). 
Безопасность основывается на хранении общего секрета, его корректной ротации и ограничении доступа. 
Решение обеспечивает проверку «сообщение не изменили, и оно от того, кто знает ключ», но не скрывает содержимое и требует безопасного обмена ключом заранее.
